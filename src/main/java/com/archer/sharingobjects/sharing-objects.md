#### 共享对象

- 同步不仅仅用于原子操作或者划定临界区，还有一个重要的方面是**内存可见性**。我们不仅希望能避免一个线程修改另一个线程正在使用的对象的状态，而且希望能确保一个线程修改了对象的状态后，其它的线程能够真正看到改变。

- 线程有着自己的缓冲区，当一个线程修改了对象的状态后，其它线程不一定能适时的刷新缓冲区，此时读取到的就是过期的数据了。而同步操作可以强制线程刷新缓冲区，这样任何线程就都可以看到其它线程对对象状态所做的修改了。

- 当一个线程在没有同步的情况下读取变量，它可能读取到一个过期值(来自于线程缓存而非主存)；更糟糕的是过期数据可能不会发生在全部变量上，也不会完全不出现：一个线程可能会得到一个变量最新的值，但是也可能得到另一个变量先前写过的过期值。

- Java存储模型要求获取和存储操作都为原子的，但是对于非volatile的long和double变量，JVM允许将64位的读或写划分为两个32位操作。如果读和写发生在不同的线程，这种情况读取一个非volatile的long变量就可能得到一个值的高32位和另一个值的低32位。

- 当线程B执行到与线程A相同的锁监视的同步块时，线程A在同步块之中或之前所做的每件事，对线程B都是可见的。**如果没用同步，就没有这样的保证。**

- 锁不仅仅是关于同步与互斥的，也是关于内存可见性的。为了保证所有线程都能看到共享的、可变变量的最新值，读取和写入线程必须使用相同的锁进行同步。

- volatile关键字确保对变量的更新以可预见的方式告知其它线程。当一个域声明为volatile类型后，编译器与运行时会监视这个变量：它是共享的，而且对它的操作不会与其它内存操作一起被重排序。volatile变量不会被缓存在寄存器或者其它对处理器不可见的缓存中。所以读取一个volatile变量时，总是返回由某个线程写入的最新值。

- volatile变量对可见性的影响所产生的价值远远高于变量本身。线程A向volatile变量写入值，线程B随后读取该变量，所有A执行写操作前可见的变量的值，在B读取了volatile变量后，成为对B也是可见的。所以从内存可见性的角度看：写入volatile变量相当于退出同步代码块，读取volatile变量相当于进入同步代码块。

- 加锁可以保证原子性和可见性，volatile只能保证可见性。

- 必须满足以下所有标准，才能使用volatile变量：
    - 写入变量时并不依赖变量的当前值，诸如i++的操作即使i是volatile类型也是没有意义的。
    - 变量不需要与其他状态变量共同参与不变约束，也就是说变量必须是独立的。
    - 访问变量时，没有其它的原因需要加锁。
    
 
- 以上，volatile变量大概很适合做状态标识吧，true/false之类的。    
 
- 当对象被封闭在一个线程中时(栈限制或ThreadLocal类)，这种做法会自动成为线程安全的，即使被封闭的对象本身并不是线程安全的。

- *线程封闭的一个特例是把它用在volatile修饰的变量上。只要能确保只通过单一的线程写入共享的volatile变量，那么在这些volatile变量上执行"读-改-写"就是线程安全的。在这种情况下，将修改限制在了单一的线程了，从而阻止了竞争条件。并且，可见性保证对volatile变量的修改其它线程能够观察到最新的值。*

- 创建后状态不能被修改的对象叫不可变对象。不可变对象天生是线程安全的。它们的域是在构造函数中创建的，既然它们的状态无法被修改，这些域永远不会变。

- 不可变性不是简单的将对象中的所有域都声明为final，所有域都是final的对象也可能是可变的，因为final域可以指向一个可变对象的引用。只有满足如下状态，一个对象才是不可变的：
    - 它的状态不能在创建以后能被修改。
    - 所有域都是final类型。
    - 它被正确创建(创建期间没有this引用的逸出)。
    
- final域是不能修改的(只能保证final修饰的引用无法修改，并不能保证不能修改对象本身的状态)，final域还可以保证初始化的安全性，初始化安全性使得不可变对象无需同步就可以被多线程自由的访问和共享。

- 不可变对象可以在没有额外同步的情况下，安全用于任意线程，甚至发布它们时也不需要同步。

- 为了安全的发布对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象，可以通过下列条件安全的发布：
    - 通过静态初始化器初始化对象的引用。
    - 将它的引用存储到volatile域或AtomicReference中。
    - 将它的引用存储到正确创建的对象的final域中。
    - 将它的引用存储到由锁保护的域中。
    
- 使用不可变的容器对象持有与不变约束相关的多个状态变量，并使用volatile确保及时的可见性，这两个前提下即使没有显示使用锁，仍然是线程安全的。
